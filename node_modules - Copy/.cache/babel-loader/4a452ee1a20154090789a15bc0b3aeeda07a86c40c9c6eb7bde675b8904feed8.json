{"ast":null,"code":"import { GRID_CHECKBOX_SELECTION_COL_DEF } from '../../../../colDef';\nimport { buildWarning } from '../../../../utils/warning';\nfunction sanitizeCellValue(value, delimiterCharacter, shouldAppendQuotes) {\n  if (typeof value === 'string') {\n    // Make sure value containing delimiter or line break won't be split into multiple rows\n    if ([delimiterCharacter, '\\n', '\\r', '\"'].some(delimiter => value.includes(delimiter))) {\n      if (shouldAppendQuotes) {\n        return \"\\\"\".concat(value.replace(/\"/g, '\"\"'), \"\\\"\");\n      }\n      return \"\".concat(value.replace(/\"/g, '\"\"'));\n    }\n    return value;\n  }\n  return value;\n}\nexport const serializeCellValue = (cellParams, options) => {\n  const {\n    delimiterCharacter,\n    ignoreValueFormatter,\n    shouldAppendQuotes\n  } = options;\n  let value;\n  if (ignoreValueFormatter) {\n    var _cellParams$value2;\n    const columnType = cellParams.colDef.type;\n    if (columnType === 'number') {\n      value = String(cellParams.value);\n    } else if (columnType === 'date' || columnType === 'dateTime') {\n      var _cellParams$value;\n      value = (_cellParams$value = cellParams.value) === null || _cellParams$value === void 0 ? void 0 : _cellParams$value.toISOString();\n    } else if (typeof ((_cellParams$value2 = cellParams.value) === null || _cellParams$value2 === void 0 ? void 0 : _cellParams$value2.toString) === 'function') {\n      value = cellParams.value.toString();\n    } else {\n      value = cellParams.value;\n    }\n  } else {\n    value = cellParams.formattedValue;\n  }\n  return sanitizeCellValue(value, delimiterCharacter, shouldAppendQuotes);\n};\nconst objectFormattedValueWarning = buildWarning(['MUI X: When the value of a field is an object or a `renderCell` is provided, the CSV export might not display the value correctly.', 'You can provide a `valueFormatter` with a string representation to be used.']);\nclass CSVRow {\n  constructor(options) {\n    this.options = void 0;\n    this.rowString = '';\n    this.isEmpty = true;\n    this.options = options;\n  }\n  addValue(value) {\n    if (!this.isEmpty) {\n      this.rowString += this.options.delimiterCharacter;\n    }\n    if (value === null || value === undefined) {\n      this.rowString += '';\n    } else if (typeof this.options.sanitizeCellValue === 'function') {\n      this.rowString += this.options.sanitizeCellValue(value, this.options.delimiterCharacter, this.options.shouldAppendQuotes);\n    } else {\n      this.rowString += value;\n    }\n    this.isEmpty = false;\n  }\n  getRowString() {\n    return this.rowString;\n  }\n}\nconst serializeRow = _ref => {\n  let {\n    id,\n    columns,\n    getCellParams,\n    delimiterCharacter,\n    ignoreValueFormatter,\n    shouldAppendQuotes\n  } = _ref;\n  const row = new CSVRow({\n    delimiterCharacter,\n    shouldAppendQuotes\n  });\n  columns.forEach(column => {\n    const cellParams = getCellParams(id, column.field);\n    if (process.env.NODE_ENV !== 'production') {\n      if (String(cellParams.formattedValue) === '[object Object]') {\n        objectFormattedValueWarning();\n      }\n    }\n    row.addValue(serializeCellValue(cellParams, {\n      delimiterCharacter,\n      ignoreValueFormatter,\n      shouldAppendQuotes\n    }));\n  });\n  return row.getRowString();\n};\nexport function buildCSV(options) {\n  const {\n    columns,\n    rowIds,\n    delimiterCharacter,\n    includeHeaders,\n    includeColumnGroupsHeaders,\n    ignoreValueFormatter,\n    apiRef,\n    shouldAppendQuotes\n  } = options;\n  const CSVBody = rowIds.reduce((acc, id) => \"\".concat(acc).concat(serializeRow({\n    id,\n    columns,\n    getCellParams: apiRef.current.getCellParams,\n    delimiterCharacter,\n    ignoreValueFormatter,\n    shouldAppendQuotes\n  }), \"\\r\\n\"), '').trim();\n  if (!includeHeaders) {\n    return CSVBody;\n  }\n  const filteredColumns = columns.filter(column => column.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field);\n  const headerRows = [];\n  if (includeColumnGroupsHeaders) {\n    const columnGroupLookup = apiRef.current.getAllGroupDetails();\n    let maxColumnGroupsDepth = 0;\n    const columnGroupPathsLookup = filteredColumns.reduce((acc, column) => {\n      const columnGroupPath = apiRef.current.getColumnGroupPath(column.field);\n      acc[column.field] = columnGroupPath;\n      maxColumnGroupsDepth = Math.max(maxColumnGroupsDepth, columnGroupPath.length);\n      return acc;\n    }, {});\n    for (let i = 0; i < maxColumnGroupsDepth; i += 1) {\n      const headerGroupRow = new CSVRow({\n        delimiterCharacter,\n        sanitizeCellValue,\n        shouldAppendQuotes\n      });\n      headerRows.push(headerGroupRow);\n      filteredColumns.forEach(column => {\n        const columnGroupId = (columnGroupPathsLookup[column.field] || [])[i];\n        const columnGroup = columnGroupLookup[columnGroupId];\n        headerGroupRow.addValue(columnGroup ? columnGroup.headerName || columnGroup.groupId : '');\n      });\n    }\n  }\n  const mainHeaderRow = new CSVRow({\n    delimiterCharacter,\n    sanitizeCellValue,\n    shouldAppendQuotes\n  });\n  filteredColumns.forEach(column => {\n    mainHeaderRow.addValue(column.headerName || column.field);\n  });\n  headerRows.push(mainHeaderRow);\n  const CSVHead = \"\".concat(headerRows.map(row => row.getRowString()).join('\\r\\n'), \"\\r\\n\");\n  return \"\".concat(CSVHead).concat(CSVBody).trim();\n}","map":{"version":3,"names":["GRID_CHECKBOX_SELECTION_COL_DEF","buildWarning","sanitizeCellValue","value","delimiterCharacter","shouldAppendQuotes","some","delimiter","includes","concat","replace","serializeCellValue","cellParams","options","ignoreValueFormatter","_cellParams$value2","columnType","colDef","type","String","_cellParams$value","toISOString","toString","formattedValue","objectFormattedValueWarning","CSVRow","constructor","rowString","isEmpty","addValue","undefined","getRowString","serializeRow","_ref","id","columns","getCellParams","row","forEach","column","field","process","env","NODE_ENV","buildCSV","rowIds","includeHeaders","includeColumnGroupsHeaders","apiRef","CSVBody","reduce","acc","current","trim","filteredColumns","filter","headerRows","columnGroupLookup","getAllGroupDetails","maxColumnGroupsDepth","columnGroupPathsLookup","columnGroupPath","getColumnGroupPath","Math","max","length","i","headerGroupRow","push","columnGroupId","columnGroup","headerName","groupId","mainHeaderRow","CSVHead","map","join"],"sources":["D:/PROJECTS/react-admin/node_modules/@mui/x-data-grid/hooks/features/export/serializers/csvSerializer.js"],"sourcesContent":["import { GRID_CHECKBOX_SELECTION_COL_DEF } from '../../../../colDef';\nimport { buildWarning } from '../../../../utils/warning';\nfunction sanitizeCellValue(value, delimiterCharacter, shouldAppendQuotes) {\n  if (typeof value === 'string') {\n    // Make sure value containing delimiter or line break won't be split into multiple rows\n    if ([delimiterCharacter, '\\n', '\\r', '\"'].some(delimiter => value.includes(delimiter))) {\n      if (shouldAppendQuotes) {\n        return `\"${value.replace(/\"/g, '\"\"')}\"`;\n      }\n      return `${value.replace(/\"/g, '\"\"')}`;\n    }\n    return value;\n  }\n  return value;\n}\nexport const serializeCellValue = (cellParams, options) => {\n  const {\n    delimiterCharacter,\n    ignoreValueFormatter,\n    shouldAppendQuotes\n  } = options;\n  let value;\n  if (ignoreValueFormatter) {\n    const columnType = cellParams.colDef.type;\n    if (columnType === 'number') {\n      value = String(cellParams.value);\n    } else if (columnType === 'date' || columnType === 'dateTime') {\n      value = cellParams.value?.toISOString();\n    } else if (typeof cellParams.value?.toString === 'function') {\n      value = cellParams.value.toString();\n    } else {\n      value = cellParams.value;\n    }\n  } else {\n    value = cellParams.formattedValue;\n  }\n  return sanitizeCellValue(value, delimiterCharacter, shouldAppendQuotes);\n};\nconst objectFormattedValueWarning = buildWarning(['MUI X: When the value of a field is an object or a `renderCell` is provided, the CSV export might not display the value correctly.', 'You can provide a `valueFormatter` with a string representation to be used.']);\nclass CSVRow {\n  constructor(options) {\n    this.options = void 0;\n    this.rowString = '';\n    this.isEmpty = true;\n    this.options = options;\n  }\n  addValue(value) {\n    if (!this.isEmpty) {\n      this.rowString += this.options.delimiterCharacter;\n    }\n    if (value === null || value === undefined) {\n      this.rowString += '';\n    } else if (typeof this.options.sanitizeCellValue === 'function') {\n      this.rowString += this.options.sanitizeCellValue(value, this.options.delimiterCharacter, this.options.shouldAppendQuotes);\n    } else {\n      this.rowString += value;\n    }\n    this.isEmpty = false;\n  }\n  getRowString() {\n    return this.rowString;\n  }\n}\nconst serializeRow = ({\n  id,\n  columns,\n  getCellParams,\n  delimiterCharacter,\n  ignoreValueFormatter,\n  shouldAppendQuotes\n}) => {\n  const row = new CSVRow({\n    delimiterCharacter,\n    shouldAppendQuotes\n  });\n  columns.forEach(column => {\n    const cellParams = getCellParams(id, column.field);\n    if (process.env.NODE_ENV !== 'production') {\n      if (String(cellParams.formattedValue) === '[object Object]') {\n        objectFormattedValueWarning();\n      }\n    }\n    row.addValue(serializeCellValue(cellParams, {\n      delimiterCharacter,\n      ignoreValueFormatter,\n      shouldAppendQuotes\n    }));\n  });\n  return row.getRowString();\n};\nexport function buildCSV(options) {\n  const {\n    columns,\n    rowIds,\n    delimiterCharacter,\n    includeHeaders,\n    includeColumnGroupsHeaders,\n    ignoreValueFormatter,\n    apiRef,\n    shouldAppendQuotes\n  } = options;\n  const CSVBody = rowIds.reduce((acc, id) => `${acc}${serializeRow({\n    id,\n    columns,\n    getCellParams: apiRef.current.getCellParams,\n    delimiterCharacter,\n    ignoreValueFormatter,\n    shouldAppendQuotes\n  })}\\r\\n`, '').trim();\n  if (!includeHeaders) {\n    return CSVBody;\n  }\n  const filteredColumns = columns.filter(column => column.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field);\n  const headerRows = [];\n  if (includeColumnGroupsHeaders) {\n    const columnGroupLookup = apiRef.current.getAllGroupDetails();\n    let maxColumnGroupsDepth = 0;\n    const columnGroupPathsLookup = filteredColumns.reduce((acc, column) => {\n      const columnGroupPath = apiRef.current.getColumnGroupPath(column.field);\n      acc[column.field] = columnGroupPath;\n      maxColumnGroupsDepth = Math.max(maxColumnGroupsDepth, columnGroupPath.length);\n      return acc;\n    }, {});\n    for (let i = 0; i < maxColumnGroupsDepth; i += 1) {\n      const headerGroupRow = new CSVRow({\n        delimiterCharacter,\n        sanitizeCellValue,\n        shouldAppendQuotes\n      });\n      headerRows.push(headerGroupRow);\n      filteredColumns.forEach(column => {\n        const columnGroupId = (columnGroupPathsLookup[column.field] || [])[i];\n        const columnGroup = columnGroupLookup[columnGroupId];\n        headerGroupRow.addValue(columnGroup ? columnGroup.headerName || columnGroup.groupId : '');\n      });\n    }\n  }\n  const mainHeaderRow = new CSVRow({\n    delimiterCharacter,\n    sanitizeCellValue,\n    shouldAppendQuotes\n  });\n  filteredColumns.forEach(column => {\n    mainHeaderRow.addValue(column.headerName || column.field);\n  });\n  headerRows.push(mainHeaderRow);\n  const CSVHead = `${headerRows.map(row => row.getRowString()).join('\\r\\n')}\\r\\n`;\n  return `${CSVHead}${CSVBody}`.trim();\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}